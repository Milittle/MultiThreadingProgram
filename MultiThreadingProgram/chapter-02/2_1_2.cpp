#include"Test02.h"

void Test02::test_2_1_2()
{
	int i = 0;
	MyStruct my(i);
	std::thread t(my);
	//这样机会出问题
	//因为t的函数引用了函数局部对象
	//这样在test_2_1_2()函数结束的时候 销毁了my和i以后 线程t对象就会出现问题
	//t.detach(); 
	//使用detach方法就会出现访问到未初始化的值

	//如果我们采用join以后就不会出现这样的问题
	//但是join只能执行一次
	//当然给我的感觉线程以这样的方式来执行并发,并不能带来很大的收益
	//这在后续的章节会陆续加入多种特性来保持并发的性能
	t.join();

	//还有一种解决方案就是将对象复制到线程对象里面,但是这样情况对于可调用对象中存在指针和引用时候,需要格外注意
	

	//当然,在多线程执行的时候,你也可以等一段时间,如果超过一定的时间以后,你就断定是超时
}