### 2.1节线程管理的基础
1. 每个程序最少有一个线程
2. 就像mian函数一样,每个线程执行一个函数,也会随着函数的结束,线程也会退出
3. 但是需要现启动一个线程
#### 2.1.1启动线程
1. 直接通过std::thread t(func); std::thread t{func}; std::thread t(lambda); 初始化并启动线程
2. 启动一个线程以后,必须在线程结束之前决定是等待一个线程还是分离一个线程(分别通过join 和 detach来对应)
3. 如果一个线程在结束之前还没有决定是 等待或者分离 那么就会在析构函数中执行std::terminate()程序就会终止
4. 如果这时你再去决定就会触发相应的异常
5. 如果不等待线程,也就是不join的时候,必须保证在线程结束之前,可访问数据的有效性(这个和单个线程是一致的)
6. 一般发生这样的情况就是,在线程还没有结束的时候,局部函数创建的线程对象分离以后,用了局部对象,这样函数的局部变量被销毁,但是线程还在使用,就会出错.


### 异常情况下的等待和分离
1. 一般的原则就是,如果决定是detach,那么就在线程启动以后,则直接detach
2. 如果是join的话,就需要特定的位置进行join
3. 因为需要考虑程序出现异常以后,也要正确处理线程对象的等待
4. 异常等待处理的话,可以通过一个线程保护类来维护一个线程的等待的调用
5. 这个线程维护类叫做资源获取即初始化(RAII)方式


### 如果不想等待,那么就detach
1. detach以后主线程和新建线程就会失去联系
2. 从而也就避免了等待时候抛出异常以后处理join的问题
3. 即使线程在后天运行着,如果程序出了异常以后,分离操作也会确保std::terminate()会在std::thread销毁以后才被调用


### 在后台运行线程 使用detach的方式
1. 分离线程不能被join
2. 也不能与主线程进行交互
3. 也不能对该线程进行引用
4. 虽然以上一些都不确保,但是c++库确保在线程结束的时候,将所属资源进行回收
5. 通常分离线程也会被叫做守护进程
6. 可detach的线程一定也是可join的,所以也可以通过joinable来检测,再决定是否进行detach