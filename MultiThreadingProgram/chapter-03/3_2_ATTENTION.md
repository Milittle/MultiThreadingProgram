### 使用互斥量来保护共享数据结构
1. 互斥量是c++中一种最通用的数据保护机制
2. 互斥量本身也有问题，会造成死锁
3. 或是对数据保护的太多或者太少

### 保护
1. 虽然有些情况使用全局变量没有问题
2. 但是大多数情况，我们将互斥量和要保护的数据会放在同一个类中
3. 而不是定义为全局变量
4. 这是面面向对象设计的准则
5. 将其放在要给类中，就可以让他们联系在一起，也可以对类的功能进行封装 并进行数据保护
6. 在这种情况下3_1.cpp程序中的add_to_list和list_contains可以作为这个类的成员函数
7. 互斥量和要保护的数据在类中可以定义为private成员这样会让访问数据的代码更加清晰
8. 当所有成员函数都会在调用时对数据上锁，结束时对数据解锁，那么就保证了数据访问时不变量不会被破坏
9. 你会发现,当我们使用引用或者指针方式来返回共享数据的话,那不也会暴露数据
10. 所以我们在设计借口的时候需要多加注意,不给留一点点后门


### 不好的设计
1. 无意之中传递了保护数据的引用或者指针



### 使用互斥量来保护共享数据结构的步骤
1. 首先确定要保护的数据,确定是否需要互斥量保护
2. 然后确定哪些函数需要加入lock_guard
3. 因为c++标准库使用RAII机制实现了mutex lock的封装,无需用户通过mutex对象的lock操作和unlock操作来实现锁
4. 一般我们将互斥量和需要保护的数据封装在一个类里面,在多个线程操作这些数据的时候,就保证了共享数据的保护
5. 那么我们叫这样的类是线程安全的
6. 再三强调: 引用和指针传参的时候,需要多加注意共享数据的传递问题


### 是否使用了互斥量以后共享数据就完事大吉?naive
1. 使用了互斥量以后,共享数据的安全一致性有时候也会出现问题
